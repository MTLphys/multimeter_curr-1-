"""
This is the internal wrapper for handling Stage controll call backs 

Generated By Matthew Larson on November 8th 2023
"""

import dearpygui.dearpygui as dpg 

# from lockinControl import *
import serial.tools.list_ports as lport
import time as t 
import re
import sys
import numpy as np 
import matplotlib.pyplot as plt 

NUM_STEPS = 10

this = sys.modules[__name__]

stages = {'k1':1,'k2':2,'k3':3, 'k4':4}#stage names vs indices
conversion = {
                'k1': {
                    'fs':43.6476698639934,
                    'ps':43647.6698639934,
                    'um':145.635555555556,
                    'mm':145635.555555556,
                    'ct':1,
                    'fs/s':43.6476698639934,
                    'ps/s':43647.6698639934,
                    'um/s':145.635555555556,
                    'mm/s':145635.555555556,
                    'ct/s':1},
                'k2': {
                    'fs':9.09705341041977,
                    'ps':9097.05341041977,
                    'um':30.3533827,
                    'mm':30353.3827,
                    'ct':1,
                    'fs/s':9.09705341041977,
                    'ps/s':9097.05341041977,
                    'um/s':30.3533827,
                    'mm/s':30353.3827,
                    'ct/s':1},
                'k3': {
                    'fs':9.09705341041977,
                    'ps':9097.05341041977,
                    'um':30.3533827,
                    'mm':30353.3827,
                    'ct':1,
                    'fs/s':9.09705341041977,
                    'ps/s':9097.05341041977,
                    'um/s':30.3533827,
                    'mm/s':30353.3827,
                    'ct/s':1},
                'k4': {
                    'fs':0.598,
                    'ps':598.0 ,
                    'um':2.0,
                    'mm':2000.0,
                    'ct':1,
                    'fs/s':0.598,
                    'ps/s':598.0,
                    'um/s':30.3533827,
                    'mm/s':2000.0,
                    'ct/s':1}
              }

this.dev = None 
#time and distance to stage count conversion factors as listed in stage manuals 
def initialize_stageControl(device):
    if (this.dev is None):
        this.dev = device
    else: 
        msg = "stageControl Already initialized"
        raise RuntimeError(msg)

def populatePorts():
    """retrieve available ports and return their base names ie 'com'
    return: 
        list (containing available ports)
    """
    portlist = []
    for cmport in lport.comports():
        portlist.append(cmport.name)
    return portlist

def connectDevice(sender,data,userdata):
    """Attempt to connect to the device of the given port names for instance 'com 1'
    Args: 
        sender(dpg object): the calling function
        data(list): the data sent in from the sender
        userdata (list):the data sent in from the  
    returns:
        0
    
    """
    try:
        port = dpg.get_value(userdata)
        this.dev.port=port
        this.dev.open()
    except:
        try:
            this.dev.close()
            raise ConnectionError('connection failed')
        except:
            raise ConnectionError('disconnect failed on startup') 

def tryCatchRW(command):
    """Attempt to write to device then read any returned information 
    error handling to close device in case of issues
    Args: 
        dev (serial obj): the serial object for connecting to the driver system
        command(str): a standard string containing a SCPI command  
    """
    try:
        #write command to serial 
        this.dev.write(command.encode())
        line=[]
        i=0
        #read response from serial device
        while(line==[]):
            i+=1
            line.append(this.dev.readline())
            if(i>10):
                line.append(' ')
        return line 
    except:
        #handle exceptions 
        this.dev.close()
        raise InterruptedError('error encountered during read/write sequence')

def closeConnect():
    """upon window close disconnect from serial device"""
    this.dev.close()
    print('device connection closed')
    

def tryCatchW(command):
    """Attempt to write to device then read any returned information 
    error handling to close device in case of issues
    Args: 
        dev (serial obj): the serial object for connecting to the driver system
        command (str): a standard string containing a SCPI command  
    """
    try:
        #write command to serial device
        this.dev.write(command.encode())
        return 0
    except:
        this.dev.close()
        raise RuntimeError('error in write sequence please restart program')

def stageSelection(stagename):
    """set the current stage in use
    Args: 
        dev (serial obj): The serial object for connecting to the 
        stagename (str): the name of the stage to be called
    
    """ 
    cmd = 'AXIS '+str(stages[stagename])+"\n"
    tryCatchW(cmd)
    
    
def waitformotion():
    """idle while waiting for device motion to complete
    """
    status =1
    statuscount= 0
    while (statuscount<5.0):
        cmd= "MOT:COND?\n"
        status = tryCatchRW(cmd)
        if len(re.findall(r'\d+', str(status)))>0:
            status=float(re.findall(r'\d+', str(status))[0])
        if(status ==0.0):
            statuscount+=1
        t.sleep(.001)
    return 0 

def moveTo(dest):
    """tell the object to move to a location then wait for motion finish

    Args:
        dest (double) : The location +/- to which the stage will move  
    """
    cmd = 'TARG '+str(dest)+"\n"
    tryCatchW(cmd)
    waitformotion()
    
def setSpeed(speed):
    """Set the speed for the device
    Args:
        speed (double): the set move speed
    """
    cmd = 'MVEL '+str(speed)+"\n"
    tryCatchW(cmd)

def zero():
    """zero device location 
    """
    cmd = 'AXIS:POS 0\n'
    tryCatchW(cmd)
    
def callPosition():
    """ask active stage for current position
    Returns:
        _str_: a string discription of the device position 
    """
    cmd = "Axis:POS?\n"
    position = tryCatchRW(cmd)
    return position

def zeroStage(sender,data,userdata):
    """Set stage position to new home position 
    Args:
        sender(dpg object): the calling function
        data(list): the data sent in from the sender 
        userdata (list):the data sent in from the  [position,sstatus,stage]
    """
    stage = dpg.get_value(userdata[2])
    stageSelection(stage)
    dpg.set_value(userdata[1],"Stage status: Zeroing")
    zero()
    dpg.set_value(userdata[0],'Current Position: 0')
    
    dpg.set_value(userdata[1],"Stage status: inactive")

def getPosition(sender,data,userdata):
    """Retrieve positional information from the active stage

    Args:
        sender(dpg object): the calling function
        data(list): the data sent in from the sender 
        userdata (list):the data sent in from the  [0position,1sstatus,2stage,3units]
    """
    stage = dpg.get_value(userdata[2])
    stageSelection(stage)
    dpg.set_value(userdata[1],stage+" Stage status: Position Query")
    
    position= callPosition()
    position= float(re.findall(r"[-+]?\d*\.\d+|[-+]?\d+", str(position))[0])
    units= dpg.get_value(userdata[3])
    position= (position/conversion[stage][units])*-2
    
    dpg.set_value(userdata[0],stage+' current Position: '+str(position))
    dpg.set_value(userdata[1],"Stage status: inactive")

def moveStage(sender,data,userdata):
    """Move the currently active stage to a new position

    Args:
        sender(dpg object): the calling function
        data(list): the data sent in from the sender 
        userdata (list):the data sent in from the  [0destination,1position,2stage
                                                    ,3units,4speed,5sunits,6sstatus]
    """
    stage= dpg.get_value(userdata[2])
    stageSelection(stage)
    dpg.set_value(userdata[6],"Stage status: Moving")
    speed = dpg.get_value(userdata[4])
    sunit = dpg.get_value(userdata[5])
    speed = speed*conversion[stage][sunit]
    setSpeed(speed)
    dest= dpg.get_value(userdata[0])
    unit =  dpg.get_value(userdata[3])
    
    position =dest*conversion[stage][unit]/-2
    moveTo(position)
    endpoint = callPosition()
    endpoint = float(re.findall(r"[-+]?\d*\.\d+|[-+]?\d+", str(endpoint))[0])
    endpoint=(endpoint/conversion[stage][unit])*-2
    dpg.set_value(userdata[1],"Current Position: "+str(endpoint))
    dpg.set_value(userdata[6],"Stage status: inactive") 
    
def runscan(sender, data, userdata):

    """Move the currently active stage to a new position"""
    stage = dpg.get_value(userdata[2])
    stageSelection(stage)
    dpg.set_value(userdata[6], "Stage status: Moving")
    speed = dpg.get_value(userdata[4])
    sunit = dpg.get_value(userdata[5])
    speed = speed * conversion[stage][sunit]
    setSpeed(speed)
    endpoint = callPosition()
    unit = dpg.get_value(userdata[3])
    endpoint = float(re.findall(r"[-+]?\d*\.\d+|[-+]?\d+", str(endpoint))[0])
    endpoint = (endpoint / conversion[stage][unit]) * -2
    dest = dpg.get_value(userdata[0])

    num_steps = dpg.get_value(userdata[8])
    mps       = dpg.get_value(userdata[9])
    
    #enumerate locations that measurments will be taken at
    stage_positions = np.linspace(endpoint,dest, num_steps)
    done = False
    for i,pos in enumerate(stage_positions):
        if i == (num_steps - 1):
            done = True
        position = pos * conversion[stage][unit] / -2
        moveTo(position)
        endpoint = callPosition()
        endpoint = float(re.findall(r"[-+]?\d*\.\d+|[-+]?\d+", str(endpoint))[0])
        endpoint = (endpoint / conversion[stage][unit]) * -2
        dpg.set_value(userdata[1], "Current Position: " + str(endpoint))
        dpg.set_value(userdata[6], "Stage status: inactive")
        controller=userdata[7] 
        #begin measuring current
        controller.start_measurements(endpoint,mps,done)
        #wait for current measurments to finish
        while( not controller.measurements_done):
            #is delay necessary?
            t.sleep(2)
        #end current measurement and start sequence for next measurement
        controller.measurements_done = False
        controller.stop_measurement()


def savefile(sender,data,userdata):
    global z
    print('saving file to: ', data['file_path_name'])
    np.savetxt(data['file_path_name'],z,delimiter=';')    
def savecanceled(sender,data,userdata):
    print('save Attempt canceled')
    print(data)